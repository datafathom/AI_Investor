"""
Orchestrator Department Agents (1.1 - 1.6)
Phase 1 Implementation: The Sovereign Kernel

This module implements the 6 agents of the Orchestrator Department,
the central nervous system of the Sovereign OS.

ACCEPTANCE CRITERIA from ROADMAP_AGENT_DEPT.md:
- Agent 1.1 (Synthesizer): Daily briefing matches ledger totals to 0.01%
- Agent 1.2 (Command Interpreter): 99% entity extraction accuracy
- Agent 1.3 (Traffic Controller): Kafka lag < 200ms during 5k msg/sec spikes
- Agent 1.4 (Layout Morphologist): UI transition in < 500ms on volatility events
- Agent 1.5 (Red-Team Sentry): Immediate SIGKILL on unsafe syscalls
- Agent 1.6 (Context Weaver): 100% context injection on role-switches
"""

import logging
import hashlib
import re
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional
from agents.base_agent import BaseAgent
from services.system.model_manager import ModelProvider

logger = logging.getLogger(__name__)


class SynthesizerAgent(BaseAgent):
    """
    Agent 1.1: The Synthesizer
    
    Aggregates all 84 agent logs into a unified strategic briefing.
    Generates the "State of the Union" daily report.
    
    Inputs:
    - Activity logs from all departments
    - Postgres ledger summaries
    - Neo4j relationship snapshots
    
    Outputs:
    - Daily Markdown briefing
    - Conflict resolution recommendations
    """

    def __init__(self) -> None:
        super().__init__(name="orchestrator.synthesizer.1.1", provider=ModelProvider.GEMINI)
        self.last_briefing_hash: Optional[str] = None
        self.conflict_queue: List[Dict[str, Any]] = []

    def process_event(self, event: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Process incoming events and aggregate into briefing data."""
        event_type = event.get("type", "")
        
        if event_type == "agent.log":
            return self._aggregate_agent_log(event)
        elif event_type == "ledger.summary":
            return self._validate_ledger_totals(event)
        elif event_type == "conflict.report":
            return self._queue_conflict(event)
        elif event_type == "briefing.request":
            return self._generate_briefing(event)
        
        return None

    def _aggregate_agent_log(self, event: Dict[str, Any]) -> Dict[str, Any]:
        """Aggregate agent activity logs for briefing synthesis."""
        agent_id = event.get("agent_id", "unknown")
        message = event.get("message", "")
        severity = event.get("severity", "info")
        
        logger.debug(f"Aggregating log from {agent_id}: {message[:50]}...")
        
        return {
            "status": "aggregated",
            "agent_id": agent_id,
            "timestamp": datetime.now(timezone.utc).isoformat(),
        }

    def _validate_ledger_totals(self, event: Dict[str, Any]) -> Dict[str, Any]:
        """
        Validate that briefing totals match Postgres ledger to 0.01%.
        
        Acceptance Criteria:
        - Daily briefing Markdown matches Postgres ledger totals to within 0.01%
        """
        ledger_total = event.get("total", 0.0)
        briefing_total = event.get("briefing_total", 0.0)
        
        if ledger_total == 0:
            variance_pct = 0.0
        else:
            variance_pct = abs(briefing_total - ledger_total) / ledger_total * 100
        
        is_valid = variance_pct <= 0.01
        
        if not is_valid:
            logger.warning(
                f"Ledger mismatch detected: Ledger={ledger_total}, "
                f"Briefing={briefing_total}, Variance={variance_pct:.4f}%"
            )
        
        return {
            "status": "validated" if is_valid else "mismatch",
            "variance_pct": variance_pct,
            "within_tolerance": is_valid,
        }

    def _queue_conflict(self, event: Dict[str, Any]) -> Dict[str, Any]:
        """Queue strategy/trader conflicts for resolution in the briefing."""
        conflict = {
            "source_agent": event.get("source", ""),
            "target_agent": event.get("target", ""),
            "description": event.get("description", ""),
            "severity": event.get("severity", "low"),
            "timestamp": datetime.now(timezone.utc).isoformat(),
        }
        self.conflict_queue.append(conflict)
        logger.info(f"Conflict queued: {conflict['source_agent']} vs {conflict['target_agent']}")
        
        return {"status": "queued", "queue_length": len(self.conflict_queue)}

    def _generate_briefing(self, event: Dict[str, Any]) -> Dict[str, Any]:
        """Generate the daily State of the Union briefing."""
        briefing_date = event.get("date", datetime.now(timezone.utc).strftime("%Y-%m-%d"))
        
        briefing_content = f"""# STATE OF THE UNION BRIEFING
## Date: {briefing_date}
## Generated by: Agent 1.1 (The Synthesizer)

### Executive Summary
[Auto-generated summary of the day's activities]

### Conflict Resolution Queue
{len(self.conflict_queue)} conflicts pending resolution.

### Ledger Verification
[Awaiting ledger sync validation]

---
*This briefing was cryptographically signed at generation time.*
"""
        
        # Hash the briefing for integrity tracking
        self.last_briefing_hash = hashlib.sha256(briefing_content.encode()).hexdigest()
        
        # Clear the conflict queue after generating briefing
        resolved_conflicts = len(self.conflict_queue)
        self.conflict_queue.clear()
        
        return {
            "status": "generated",
            "briefing_hash": self.last_briefing_hash,
            "conflicts_resolved": resolved_conflicts,
            "content": briefing_content,
        }


class CommandInterpreterAgent(BaseAgent):
    """
    Agent 1.2: The Command Interpreter
    
    Translates Voice/Text commands into structured JSON system calls.
    Uses NER (Named Entity Recognition) for entity extraction.
    
    Acceptance Criteria:
    - 99% accuracy on entity extraction (Tickers, Accounts, Dates)
    """

    # Whitelist of recognized command verbs
    COMMAND_VERBS = [
        "BUY", "SELL", "HOLD", "TRANSFER", "REBALANCE", "AUDIT",
        "HARVEST", "SWEEP", "ALERT", "CANCEL", "APPROVE", "REJECT",
    ]

    # Regex patterns for entity extraction
    TICKER_PATTERN = re.compile(r'\b([A-Z]{1,5})\b')
    AMOUNT_PATTERN = re.compile(r'\$?([\d,]+(?:\.\d{2})?)')
    DATE_PATTERN = re.compile(r'\b(\d{4}-\d{2}-\d{2})\b')

    def __init__(self) -> None:
        super().__init__(name="orchestrator.interpreter.1.2", provider=ModelProvider.GEMINI)
        self.interpretation_count: int = 0
        self.accuracy_tracker: List[bool] = []

    def process_event(self, event: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Process natural language commands into structured JSON."""
        event_type = event.get("type", "")
        
        if event_type in ("command.text", "command.voice"):
            return self._interpret_command(event)
        elif event_type == "accuracy.feedback":
            return self._record_feedback(event)
        
        return None

    def _interpret_command(self, event: Dict[str, Any]) -> Dict[str, Any]:
        """
        Parse a natural language command into a structured JSON call.
        
        Example:
        Input: "Buy 100 shares of AAPL tomorrow"
        Output: {"verb": "BUY", "ticker": "AAPL", "quantity": 100, "date": "..."}
        """
        raw_text = event.get("text", "").upper()
        self.interpretation_count += 1
        
        # Extract verb
        detected_verb = None
        for verb in self.COMMAND_VERBS:
            if verb in raw_text:
                detected_verb = verb
                break
        
        # Extract entities
        tickers = self.TICKER_PATTERN.findall(raw_text)
        amounts = self.AMOUNT_PATTERN.findall(raw_text)
        dates = self.DATE_PATTERN.findall(raw_text)
        
        # Filter out verb from tickers
        tickers = [t for t in tickers if t not in self.COMMAND_VERBS]
        
        result = {
            "status": "interpreted",
            "original_text": event.get("text", ""),
            "structured_call": {
                "verb": detected_verb,
                "tickers": tickers[:3] if tickers else [],  # Limit to 3 tickers
                "amounts": [float(a.replace(",", "")) for a in amounts[:2]] if amounts else [],
                "dates": dates[:1] if dates else [],
            },
            "confidence": 0.95 if detected_verb else 0.5,
            "interpretation_id": self.interpretation_count,
        }
        
        logger.info(f"Command interpreted: {detected_verb} -> {tickers}")
        return result

    def _record_feedback(self, event: Dict[str, Any]) -> Dict[str, Any]:
        """Record accuracy feedback for tracking."""
        was_correct = event.get("correct", True)
        self.accuracy_tracker.append(was_correct)
        
        # Keep last 1000 for rolling accuracy
        if len(self.accuracy_tracker) > 1000:
            self.accuracy_tracker = self.accuracy_tracker[-1000:]
        
        accuracy = sum(self.accuracy_tracker) / len(self.accuracy_tracker) * 100
        
        return {
            "status": "feedback_recorded",
            "current_accuracy": accuracy,
            "sample_size": len(self.accuracy_tracker),
        }


class TrafficControllerAgent(BaseAgent):
    """
    Agent 1.3: The Traffic Controller
    
    Manages Kafka backpressure and message routing.
    
    Acceptance Criteria:
    - Consumer lag for `market.live` topic remains < 200ms during 5k msg/sec spikes
    """

    def __init__(self) -> None:
        super().__init__(name="orchestrator.traffic.1.3", provider=ModelProvider.GEMINI)
        self.current_lag_ms: float = 0.0
        self.message_rate: float = 0.0
        self.backpressure_active: bool = False

    def process_event(self, event: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Monitor Kafka metrics and apply backpressure if needed."""
        event_type = event.get("type", "")
        
        if event_type == "kafka.metrics":
            return self._process_metrics(event)
        elif event_type == "backpressure.check":
            return self._check_backpressure()
        
        return None

    def _process_metrics(self, event: Dict[str, Any]) -> Dict[str, Any]:
        """Process Kafka consumer metrics."""
        self.current_lag_ms = event.get("consumer_lag_ms", 0.0)
        self.message_rate = event.get("messages_per_sec", 0.0)
        
        # Apply backpressure if lag exceeds threshold
        lag_threshold_ms = 200.0
        if self.current_lag_ms > lag_threshold_ms and not self.backpressure_active:
            self.backpressure_active = True
            logger.warning(
                f"Backpressure ACTIVATED: Lag={self.current_lag_ms}ms > {lag_threshold_ms}ms"
            )
        elif self.current_lag_ms <= lag_threshold_ms and self.backpressure_active:
            self.backpressure_active = False
            logger.info("Backpressure RELEASED: Lag normalized")
        
        return {
            "status": "metrics_processed",
            "lag_ms": self.current_lag_ms,
            "rate_per_sec": self.message_rate,
            "backpressure": self.backpressure_active,
        }

    def _check_backpressure(self) -> Dict[str, Any]:
        """Return current backpressure status."""
        return {
            "backpressure_active": self.backpressure_active,
            "current_lag_ms": self.current_lag_ms,
            "meets_sla": self.current_lag_ms < 200.0,
        }


class LayoutMorphologistAgent(BaseAgent):
    """
    Agent 1.4: The Layout Morphologist
    
    Predictive UI management based on context and events.
    
    Acceptance Criteria:
    - Auto-transition to Trader HUD within 500ms of high-volatility event detection
    """

    def __init__(self) -> None:
        super().__init__(name="orchestrator.layout.1.4", provider=ModelProvider.GEMINI)
        self.current_layout: str = "mission_control"
        self.volatility_threshold: float = 0.02  # 2% move triggers transition

    def process_event(self, event: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Process events and trigger layout transitions."""
        event_type = event.get("type", "")
        
        if event_type == "market.volatility":
            return self._check_volatility_trigger(event)
        elif event_type == "layout.switch":
            return self._switch_layout(event)
        
        return None

    def _check_volatility_trigger(self, event: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Check if volatility warrants a layout transition."""
        volatility = event.get("volatility", 0.0)
        
        if abs(volatility) > self.volatility_threshold:
            logger.info(f"High volatility detected ({volatility:.2%}), switching to Trader HUD")
            return self._switch_layout({"target": "trader_hud", "reason": "volatility_spike"})
        
        return None

    def _switch_layout(self, event: Dict[str, Any]) -> Dict[str, Any]:
        """Switch the UI layout."""
        target = event.get("target", "mission_control")
        reason = event.get("reason", "user_request")
        
        previous = self.current_layout
        self.current_layout = target
        
        return {
            "status": "layout_switched",
            "from": previous,
            "to": target,
            "reason": reason,
            "timestamp": datetime.now(timezone.utc).isoformat(),
        }


class RedTeamSentryAgent(BaseAgent):
    """
    Agent 1.5: The Red-Team Sentry
    
    Syscall monitoring and security enforcement.
    
    Acceptance Criteria:
    - Immediate SIGKILL on any agent attempting os.system or eval outside whitelist
    """

    # Dangerous patterns that should never be executed
    BLOCKED_PATTERNS = [
        "os.system", "subprocess.call", "subprocess.run", "subprocess.Popen",
        "eval(", "exec(", "__import__", "compile(",
    ]

    # Whitelist of agents allowed to use restricted syscalls (empty by default)
    SYSCALL_WHITELIST: List[str] = []

    def __init__(self) -> None:
        super().__init__(name="orchestrator.sentry.1.5", provider=ModelProvider.GEMINI)
        self.violation_count: int = 0
        self.killed_agents: List[str] = []

    def process_event(self, event: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Monitor for security violations."""
        event_type = event.get("type", "")
        
        if event_type == "syscall.audit":
            return self._audit_syscall(event)
        elif event_type == "code.review":
            return self._review_code(event)
        
        return None

    def _audit_syscall(self, event: Dict[str, Any]) -> Dict[str, Any]:
        """Audit a syscall attempt from an agent."""
        agent_id = event.get("agent_id", "unknown")
        syscall = event.get("syscall", "")
        
        # Check if agent is whitelisted
        if agent_id in self.SYSCALL_WHITELIST:
            return {"status": "allowed", "agent_id": agent_id, "reason": "whitelisted"}
        
        # Check for blocked patterns
        for pattern in self.BLOCKED_PATTERNS:
            if pattern in syscall:
                self.violation_count += 1
                self.killed_agents.append(agent_id)
                
                logger.critical(
                    f"SECURITY VIOLATION: Agent '{agent_id}' attempted blocked syscall: {pattern}"
                )
                
                return {
                    "status": "SIGKILL",
                    "agent_id": agent_id,
                    "violation": pattern,
                    "action": "immediate_termination",
                    "total_violations": self.violation_count,
                }
        
        return {"status": "allowed", "agent_id": agent_id}

    def _review_code(self, event: Dict[str, Any]) -> Dict[str, Any]:
        """Review code for security violations before execution."""
        code = event.get("code", "")
        agent_id = event.get("agent_id", "unknown")
        
        violations = []
        for pattern in self.BLOCKED_PATTERNS:
            if pattern in code:
                violations.append(pattern)
        
        if violations:
            return {
                "status": "rejected",
                "agent_id": agent_id,
                "violations": violations,
                "message": "Code contains blocked patterns",
            }
        
        return {"status": "approved", "agent_id": agent_id}


class ContextWeaverAgent(BaseAgent):
    """
    Agent 1.6: The Context Weaver
    
    Maintains Redis-based session memory for LLM prompts.
    
    Acceptance Criteria:
    - Injects relevant context (last 5 actions) into 100% of departmental role-switches
    """

    def __init__(self) -> None:
        super().__init__(name="orchestrator.weaver.1.6", provider=ModelProvider.GEMINI)
        self.context_buffer: List[Dict[str, Any]] = []
        self.max_context_items: int = 5

    def process_event(self, event: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Manage context for agent interactions."""
        event_type = event.get("type", "")
        
        if event_type == "action.completed":
            return self._record_action(event)
        elif event_type == "context.request":
            return self._provide_context(event)
        elif event_type == "role.switch":
            return self._inject_context_for_switch(event)
        
        return None

    def _record_action(self, event: Dict[str, Any]) -> Dict[str, Any]:
        """Record a completed action to the context buffer."""
        action = {
            "agent_id": event.get("agent_id", "unknown"),
            "action": event.get("action", ""),
            "result": event.get("result", ""),
            "timestamp": datetime.now(timezone.utc).isoformat(),
        }
        
        self.context_buffer.append(action)
        
        # Keep only the last N items
        if len(self.context_buffer) > self.max_context_items:
            self.context_buffer = self.context_buffer[-self.max_context_items:]
        
        return {"status": "recorded", "buffer_size": len(self.context_buffer)}

    def _provide_context(self, event: Dict[str, Any]) -> Dict[str, Any]:
        """Provide the current context buffer."""
        return {
            "status": "context_provided",
            "context": self.context_buffer.copy(),
            "item_count": len(self.context_buffer),
        }

    def _inject_context_for_switch(self, event: Dict[str, Any]) -> Dict[str, Any]:
        """Inject context when switching to a different department role."""
        target_department = event.get("target_department", "")
        
        # Format context for LLM injection
        context_text = "\n".join([
            f"- [{c['timestamp']}] {c['agent_id']}: {c['action']} -> {c['result']}"
            for c in self.context_buffer
        ])
        
        logger.info(f"Context injected for switch to {target_department}")
        
        return {
            "status": "context_injected",
            "target_department": target_department,
            "context_items": len(self.context_buffer),
            "context_text": context_text,
        }


# =============================================================================
# Agent Registry
# =============================================================================

def get_orchestrator_agents() -> Dict[str, BaseAgent]:
    """
    Factory function to instantiate all Orchestrator department agents.
    
    Returns:
        Dictionary mapping agent IDs to agent instances.
    """
    return {
        "orchestrator.synthesizer.1.1": SynthesizerAgent(),
        "orchestrator.interpreter.1.2": CommandInterpreterAgent(),
        "orchestrator.traffic.1.3": TrafficControllerAgent(),
        "orchestrator.layout.1.4": LayoutMorphologistAgent(),
        "orchestrator.sentry.1.5": RedTeamSentryAgent(),
        "orchestrator.weaver.1.6": ContextWeaverAgent(),
    }
