"""
==============================================================================
FILE: services/strategy/rebalance_engine.py
ROLE: Portfolio Pilot
PURPOSE:
    Orchestrate the alignment of current portfolio holdings with target
    allocations generated by the DynamicAllocator.
    
    1. Drift Detection:
       - Compare current weights vs target weights.
       - Trigger rebalancing if any asset drifts > 5% (fixed threshold).
       
    2. Order Generation:
       - Convert weight differences into share-based BUY/SELL orders.
       
CONTEXT: 
    Part of Phase 33: Autonomous Rebalancing.
    This module makes the system "self-correcting" without human intervention.
==============================================================================
"""

import logging
from typing import Dict, List, Any

logger = logging.getLogger(__name__)

class RebalanceEngine:
    def __init__(self, drift_threshold: float = 0.05):
        """
        threshold = 0.05 means 5% drift from target.
        """
        self.drift_threshold = drift_threshold

    def calculate_drift(self, 
                        current_weights: Dict[str, float], 
                        target_weights: Dict[str, float]) -> Dict[str, float]:
        """
        Calculate weight differences. Positive = Overweight, Negative = Underweight.
        """
        drift = {}
        all_symbols = set(current_weights.keys()) | set(target_weights.keys())
        
        for symbol in all_symbols:
            c_w = current_weights.get(symbol, 0.0)
            t_w = target_weights.get(symbol, 0.0)
            drift[symbol] = c_w - t_w
            
        return drift

    def check_rebalance_needed(self, drift: Dict[str, float]) -> bool:
        """
        Returns True if any absolute drift exceeds threshold.
        """
        for sym, d in drift.items():
            if abs(d) >= self.drift_threshold:
                return True
        return False

    def generate_rebalance_orders(self, 
                                  drift: Dict[str, float], 
                                  portfolio_value: float,
                                  current_prices: Dict[str, float]) -> List[Dict[str, Any]]:
        """
        Generate orders to fix drift.
        Positive Drift (Overweight) -> SELL
        Negative Drift (Underweight) -> BUY
        """
        orders = []
        for symbol, d in drift.items():
            if abs(d) < 0.001: # Ignore tiny noise
                continue
                
            value_diff = d * portfolio_value
            price = current_prices.get(symbol)
            
            if not price:
                logger.warning(f"Price missing for {symbol}, cannot rebalance.")
                continue
                
            shares = int(abs(value_diff) / price)
            if shares == 0:
                continue
                
            side = "SELL" if value_diff > 0 else "BUY"
            orders.append({
                "symbol": symbol,
                "side": side,
                "quantity": shares,
                "reason": f"Rebalancing drift: {d*100:.1f}%"
            })
            
        return orders

# Singleton
_instance = None

def get_rebalance_engine() -> RebalanceEngine:
    global _instance
    if _instance is None:
        _instance = RebalanceEngine()
    return _instance
